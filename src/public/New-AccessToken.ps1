Function New-AccessToken {
    <#
        .SYNOPSIS
        This function will help you to generate tokens (Access/Refresh/Id) with multiple OAUTH2 flows.
        .DESCRIPTION
        This function will help you to generate tokens (Access/Refresh/Id) with multiple OAUTH2 flows. This command is an abstraction of the complexity
        generated by the multiple flows. This function will check is a cache exist and use it except if you decide to use the withoucache parameter.
        In addition, you can decide to use this function in conjunction with secret.
        WARNING: This module is mainly for learning OAUTH/OIDC purpose. You should consider using the MSAL.PS module if you plan to do OAUTH in production.
        .PARAMETER Resource
        Specify the resource you try to reach (clientId)
        .PARAMETER Scope
        Specify the scope
        .PARAMETER RedirectUri
        Specify the RedirectUri of the application
        .PARAMETER TenantId
        Specify the tenantId (with guid)
        .PARAMETER Secret
        Specify the secret of the clientId
        .PARAMETER CertificatePath
        Specify the certificate to use for the authentication. Should come from a installed pfx under the form "Cert:\CurrentUser\My\<cert thumbprint>"
        .PARAMETER WithoutCache
        Specify you don't want to use the local cache
        .PARAMETER AuthCodeFlow
        Specify you want to authenticate using the AuthCodeFlow
        .PARAMETER DeviceCodeFlow
        Specify you want to authenticate using the DeviceCodeFlow
        .PARAMETER ClientCredentialFlow
        Specify you want to authenticate using the ClientCredentialFlow
        .EXAMPLE
        PS> $ClientId = 'd3537907-7a6f-54be-8a83-601d70feec72'
            $TenantId = 'e192cada-b64d-4cfc-8b90-d14338b2c7ec'

            $Splatting = @{
                Resource     = $ClientId
                TenantId     = $TenantId
                Scope        = 'https://graph.microsoft.com/.default openid offline_access'
                RedirectUri  = 'https://login.microsoftonline.com/common/oauth2/nativeclient'
                AuthCodeFlow = $true
                verbose      = $true
            }
        
        "will authenticate using the auth code flow."
        .EXAMPLE
        PS> $ClientId = 'd3537907-7a6f-54be-8a83-601d70feec72'
            $TenantId = 'e192cada-b64d-4cfc-8b90-d14338b2c7ec'

            $Splatting = @{
                Resource     = $ClientId
                TenantId     = $TenantId
                Scope        = 'https://graph.microsoft.com/.default openid offline_access'
                RedirectUri  = 'https://login.microsoftonline.com/common/oauth2/nativeclient'
                Secret       = 'mysecret'
                AuthCodeFlow = $true
                verbose      = $true
            }
        
        "will authenticate using the auth code flow."
        .NOTES
        VERSION HISTORY
        1.0 | 2021/05/05 | Francois LEON
            initial version
        POSSIBLE IMPROVEMENT
            - Add Certificate authentication
        #>
    [cmdletbinding()]
    param(
        [parameter(Mandatory = $true)]
        [guid]$Resource,
        [parameter(Mandatory = $true)]
        [string]$Scope,
        [string]$RedirectUri,
        [parameter(Mandatory = $true)]
        [guid]$TenantId,
        [parameter(Mandatory, ParameterSetName = 'AuthCodeFlow')]
        [switch]$AuthCodeFlow,
        [switch]$WithoutCache,
        [parameter(ParameterSetName = 'AuthCodeFlow')]
        [parameter(Mandatory, ParameterSetName = 'ClientCredentialFlowSecret')]
        [string]$Secret,
        [parameter(Mandatory, ParameterSetName = 'ClientCredentialFlowCert')]
        $CertificatePath,  # Should be under the form "Cert:\CurrentUser\My\<cert thumbprint>"
        [parameter(Mandatory, ParameterSetName = 'DeviceCodeFlow')]
        [switch]$DeviceCodeFlow,
        [parameter(Mandatory, ParameterSetName = 'ClientCredentialFlowSecret')]
        [parameter(Mandatory, ParameterSetName = 'ClientCredentialFlowCert')]
        [switch]$ClientCredentialFlow
    )
    # TenantId for a single tenant app or you can use common if it's a multi tenant app
    Write-Verbose 'New-AccessToken - Begin function'

    #Define $HOMEPath variable dependin the platform
    $HOMEPath = Get-HomePath
    $FullPath = Join-Path -Path $HOMEPath -ChildPath '.psoauth2' -AdditionalChildPath 'accessTokens.json'

    #In case of an issue with the cache folder
    New-CredentialCacheFolder

    #Should return $null or a context
    #Because AAD does not return exactly what we've asked for scopes I have to change the way I write it in cache
    $InterrestingScopes = ($($scope.replace('https://graph.microsoft.com/', '')) -split ' ').where( { $_ -notin @('email', 'openid', 'profile', 'offline_access') }) | Join-String -Separator ' ' | Sort-Object
    $Cache = Get-TokenFromCache -Scope $InterrestingScopes -resource $Resource

    $NoRT = $false
    $IsATExpired = $false
    if ($Cache) {
        # Here means there is a context detected in the cache but we want to check if a RT exist
        Write-Verbose 'New-AccessToken - Cache context found'
        if ($null -eq $Cache.refreshToken) {
            Write-Verbose 'New-AccessToken - No Refresh token found'
            $NoRT = $true
        }

        #Check AT expiration
        $CurrentUTCDate = (Get-Date).ToUniversalTime()
        #Convert string to specific format for comparison
        $ContextCacheUTCDate = [datetime]::parseexact($($Cache.Expired_date_utc), 'yyyyMMddHHmmss', $null)
        #We want to know when the AT will expire. If it's less than a minute, renew it
        [int]$TimespanInSeconds = (New-TimeSpan -Start $CurrentUTCDate -End $ContextCacheUTCDate).TotalSeconds

        if ($TimespanInSeconds -lt 60) {
            Write-Verbose 'New-AccessToken - Access token is expired'
            $IsATExpired = $true
        }
    }

    if ($AuthCodeFlow) {
        Write-Verbose 'New-AccessToken - Auth code flow selected'
        #if #No cache or expired AT without RT
        if ($WithoutCache) {
            Write-Verbose 'New-AccessToken - Execute without cache has been selected (no cache used or generated)'
            # Here we just want to generate a token without any trace and without using the cache
            # FORCE INTERRACTIVE LOGIN
            #IMPORTANT HOW TO MANAGE S+CONFIDENTIAL APP

            #Generate a verifier for the state (just a random 43 char string)
            #State is a security to avoid Cross site request forgery (https://tools.ietf.org/html/rfc6749#section-10.12)
            $State = New-CodeVerifier
            # Generate a pair verifier/ Code challenge
            $CodeChallenge = New-AllowedCodeChallenge

            $Splatting = @{
                Clientid      = $Resource
                RedirectUri   = $RedirectUri
                TenantId      = $TenantId
                Scope         = $scope
                State         = $State
                CodeChallenge = $CodeChallenge.CodeChallenge
            }

            #Web view should pop. Enter your creds.
            $Code = New-AuthorizationCode @Splatting
            
            $Splatting = @{
                Clientid    = $Resource
                RedirectUri = $RedirectUri
                TenantId    = $TenantId
                Scope       = $scope
                verifier    = $CodeChallenge.Verifier
                AuthCode    = $Code.code
                Secret      = (($null -ne $secret) ? $secret : $null)
            }

            #Here we should have at least AT. If OIDC AT+ID + If offline AT+ID+RT
            $Tokens = New-TokenFromAuthorizationCode @Splatting
            return $tokens.access_token
        }
        elseif (($null -eq $cache) -OR (($IsATExpired -eq $true) -AND ($NoRT -eq $true))) {

            Write-Verbose 'New-AccessToken - No cache found or Access token expired without available refresh token'
            # FORCE INTERRACTIVE LOGIN

            #Generate a verifier for the state (just a random 43 char string)
            #State is a security to avoid Cross site request forgery (https://tools.ietf.org/html/rfc6749#section-10.12)
            $State = New-CodeVerifier
            # Generate a pair verifier/ Code challenge
            $CodeChallenge = New-AllowedCodeChallenge

            $Splatting = @{
                Clientid      = $Resource
                RedirectUri   = $RedirectUri
                TenantId      = $TenantId
                Scope         = $scope
                State         = $State
                CodeChallenge = $CodeChallenge.CodeChallenge
            }

            #Web view should pop. Enter your creds.
            $Code = New-AuthorizationCode @Splatting

            $Splatting = @{
                Clientid    = $Resource
                RedirectUri = $RedirectUri
                TenantId    = $TenantId
                Scope       = $scope
                verifier    = $CodeChallenge.Verifier
                AuthCode    = $Code.code
                Secret      = (($null -ne $secret) ? $secret : $null)
            }

            #Here we should have at least AT. If OIDC AT+ID + If offline AT+ID+RT
            $Tokens = New-TokenFromAuthorizationCode @Splatting

            #Access Token will be expired 1 hour later
            $Obj = [pscustomobject]@{
                TokenType        = 'Bearer'
                idToken          = $Tokens.id_token
                scope            = $InterrestingScopes
                resource         = $Resource
                refreshToken     = $Tokens.refresh_token
                accessToken      = $Tokens.access_token
                Expired_date_utc = (Get-Date).addhours(1).ToUniversalTime().ToString('yyyyMMddHHmmss')
                Secret           = (($null -ne $secret) ? $secret : $null)
            }
        
            #Read current cache issue if file does not exist (IMPORTANT)
            Write-Verbose 'New-AccessToken - Read the cache file'
            [array]$CurrentTokenCache = Get-Content $FullPath -Raw | ConvertFrom-Json
            if ($cache) {
                #A context has been detected update the file
                Write-Verbose 'New-AccessToken - Context found, update the context'
                $UpdatedTokenCache = $CurrentTokenCache | Where-Object { ($_.resource -ne $Resource) -AND ($_.scope -ne $InterrestingScopes) }
                $UpdatedTokenCache += $obj
                $UpdatedTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8
            }
            else {
                #No context add a new entry
                Write-Verbose 'New-AccessToken - No context found, add a new entry in the cache'
                $CurrentTokenCache += $obj
                $CurrentTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8
            }

            return $Tokens.access_token
        }
        else {
            # NON INTERRACTIVE PART
            #Here means: a context exist in cache with a RT
            if ($IsATExpired) {
                Write-Verbose 'New-AccessToken - Access token is expired and a refresh token is found in the cache, go use it'
                $refreshToken = $Cache.refreshToken
                $Splatting = @{
                    Clientid     = $Resource
                    RedirectUri  = $RedirectUri
                    TenantId     = $TenantId
                    Scope        = $scope
                    RefreshToken = $refreshToken
                    Secret       = (($null -ne $secret) ? $cache.secret : $null)
                }

                $Tokens = New-RefreshToken @Splatting

                #AT will be expired one hour later.
                $Obj = [pscustomobject]@{
                    TokenType        = 'Bearer'
                    idToken          = $Tokens.id_token
                    scope            = $InterrestingScopes
                    resource         = $Resource
                    refreshToken     = $Tokens.refresh_token
                    accessToken      = $Tokens.access_token
                    Expired_date_utc = (Get-Date).addhours(1).ToUniversalTime().ToString('yyyyMMddHHmmss')
                    Secret           = (($null -ne $secret) ? $cache.secret : $null)
                }

                #A context has been detected update the file
                Write-Verbose 'New-AccessToken - update the context in the cache'
                $UpdatedTokenCache = $CurrentTokenCache | Where-Object { ($_.resource -ne $Resource) -AND ($_.scope -ne $InterrestingScopes) }
                $UpdatedTokenCache += $obj
                $UpdatedTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8

                return $Tokens.access_token
            }
            else {
                # AT not expired yet, let's use the cache
                Write-Verbose 'New-AccessToken - Access token not expired, go use it'
                return $Cache.accessToken
            }
        }
    }
    elseif ($DeviceCodeFlow) {
        Write-Verbose 'New-AccessToken - Device code flow selected'
        # Full public flow. Try to add a secret and you will have an error
        if ($WithoutCache) {
            Write-Verbose 'New-AccessToken - Execute without cache has been selected (no cache used or generated)'
            $Splatting = @{
                Clientid = $Resource
                TenantId = $TenantId
                Scope    = $scope
            }

            #Here we should have at least AT. If OIDC AT+ID + If offline AT+ID+RT
            $Tokens = New-DeviceCode @Splatting
            return $Tokens.access_token
            
        }
        elseif (($null -eq $cache) -OR (($IsATExpired -eq $true) -AND ($NoRT -eq $true))) {
            Write-Verbose 'New-AccessToken - No cache found or Access token expired without available refresh token'
            #No cache found or expired or no RT, INTERRACTIVE LOGIN
            $Splatting = @{
                Clientid = $Resource
                TenantId = $TenantId
                Scope    = $scope
            }

            #Here we should have at least AT. If OIDC AT+ID + If offline AT+ID+RT
            $Tokens = New-DeviceCode @Splatting

            #Access Token will be expired 1 hour later
            $Obj = [pscustomobject]@{
                TokenType        = 'Bearer'
                idToken          = $Tokens.id_token
                scope            = $InterrestingScopes
                resource         = $Resource
                refreshToken     = $Tokens.refresh_token
                accessToken      = $Tokens.access_token
                Expired_date_utc = (Get-Date).addhours(1).ToUniversalTime().ToString('yyyyMMddHHmmss')
                Secret           = (($null -ne $secret) ? $secret : $null)
            }
        
            #Read current cache issue if file does not exist (IMPORTANT)
            [array]$CurrentTokenCache = Get-Content $FullPath -Raw | ConvertFrom-Json
            Write-Verbose 'New-AccessToken - Read the cache file'
            if ($cache) {
                #A context has been detected update the file
                Write-Verbose 'New-AccessToken - Context found, update the context'
                $UpdatedTokenCache = $CurrentTokenCache | Where-Object { ($_.resource -ne $Resource) -AND ($_.scope -ne $InterrestingScopes) }
                $UpdatedTokenCache += $obj
                $UpdatedTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8
            }
            else {
                #No context add a new entry
                Write-Verbose 'New-AccessToken - No context found, add new entry'
                $CurrentTokenCache += $obj
                $CurrentTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8
            }

            return $Tokens.access_token
        }
        else {
            # NON INTERRACTIVE PART
            #Here means: a context exist in cache with a RT
            if ($IsATExpired) {
                Write-Verbose 'New-AccessToken - Access token expired, use refresh token'
                $refreshToken = $Cache.refreshToken
                $Splatting = @{
                    Clientid     = $Resource
                    Scope        = $scope
                    RefreshToken = $refreshToken
                }

                $Tokens = New-RefreshToken @Splatting

                #AT will be expired one hour later.
                $Obj = [pscustomobject]@{
                    TokenType        = 'Bearer'
                    idToken          = $Tokens.id_token
                    scope            = $InterrestingScopes
                    resource         = $Resource
                    refreshToken     = $Tokens.refresh_token
                    accessToken      = $Tokens.access_token
                    Expired_date_utc = (Get-Date).addhours(1).ToUniversalTime().ToString('yyyyMMddHHmmss')
                    Secret           = (($null -ne $secret) ? $cache.secret : $null)
                }

                #A context has been detected update the file
                Write-Verbose 'New-AccessToken - Context found, update the context'
                $UpdatedTokenCache = $CurrentTokenCache | Where-Object { ($_.resource -ne $Resource) -AND ($_.scope -ne $InterrestingScopes) }
                $UpdatedTokenCache += $obj
                $UpdatedTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8

                return $Tokens.access_token
            }
            else {
                # AT not expired yet, let's use the cache
                Write-Verbose 'Access token (not expired) returned from local cache directly'
                return $Cache.accessToken
            }
        }
    }
    elseif ($ClientCredentialFlow) {
        Write-Verbose 'New-AccessToken - Credential flow selected'
        # This is a confidential flow. No Interractive flow is allowed in this flow. Refresh Token is not possible in this flow.
        if ($WithoutCache) {
            Write-Verbose 'New-AccessToken - Execute without cache has been selected (no cache used or generated)'
            if ($Secret) {
                $Splatting = @{
                    Clientid = $Resource
                    TenantId = $TenantId
                    Scope    = $scope
                    Secret   = $Secret
                }
            }
            else {
                # Means certificate instead of secret
                $Splatting = @{
                    Clientid        = $Resource
                    TenantId        = $TenantId
                    Scope           = $scope
                    CertificatePath = $CertificatePath
                }
            }
            

            $Tokens = New-ClientCredential @Splatting
            return $Tokens.access_token
        }
        elseif (($null -eq $cache) -OR ($IsATExpired -eq $true)) {
            Write-Verbose 'New-AccessToken - No cache found or Access token expired'
            #No cache found or expired
            if ($Secret) {
                $Splatting = @{
                    Clientid = $Resource
                    TenantId = $TenantId
                    Scope    = $scope
                    Secret   = $Secret
                }
            }
            else {
                # Means certificate instead of secret
                $Splatting = @{
                    Clientid        = $Resource
                    TenantId        = $TenantId
                    Scope           = $scope
                    CertificatePath = $CertificatePath
                }
            }

            $Tokens = New-ClientCredential @Splatting

            #Access Token will be expired 1 hour later
            if ($Secret) {
                $Obj = [pscustomobject]@{
                    TokenType        = 'Bearer'
                    idToken          = $null
                    scope            = $InterrestingScopes
                    resource         = $Resource
                    refreshToken     = $null
                    accessToken      = $Tokens.access_token
                    Expired_date_utc = (Get-Date).addhours(1).ToUniversalTime().ToString('yyyyMMddHHmmss')
                    Secret           = $Secret
                }
            }
            else {
                $Obj = [pscustomobject]@{
                    TokenType        = 'Bearer'
                    idToken          = $null
                    scope            = $InterrestingScopes
                    resource         = $Resource
                    refreshToken     = $null
                    accessToken      = $Tokens.access_token
                    Expired_date_utc = (Get-Date).addhours(1).ToUniversalTime().ToString('yyyyMMddHHmmss')
                    CertificatePath  = $CertificatePath
                }
            }
        
            #Read current cache issue if file does not exist (IMPORTANT)
            Write-Verbose 'New-AccessToken - Read local cache'
            [array]$CurrentTokenCache = Get-Content $FullPath -Raw | ConvertFrom-Json
            if ($cache) {
                #A context has been detected update the file
                Write-Verbose 'New-AccessToken - Context found, update context'
                $UpdatedTokenCache = $CurrentTokenCache | Where-Object { ($_.resource -ne $Resource) -AND ($_.scope -ne $InterrestingScopes) }
                $UpdatedTokenCache += $obj
                $UpdatedTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8
            }
            else {
                #No context add a new entry
                Write-Verbose 'New-AccessToken - No context found, add new entry'
                $CurrentTokenCache += $obj
                $CurrentTokenCache | ConvertTo-Json | Out-File -FilePath $FullPath -Encoding UTF8
            }

            return $Tokens.access_token
        }
        else {
            # AT not expired yet, let's use the cache
            Write-Verbose 'Access token (none expired) returned from local cache directly'
            return $Cache.accessToken
        }
    }
}